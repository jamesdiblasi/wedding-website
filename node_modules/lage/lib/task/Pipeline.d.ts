import { Config } from "../types/Config";
import { PackageInfos } from "workspace-tools";
import { RunContext } from "../types/RunContext";
import { PipelineTarget, TargetConfig, TargetConfigFactory } from "../types/PipelineDefinition";
import { TopologicalGraph } from "../types/TopologicalGraph";
import { Workspace } from "../types/Workspace";
export declare const START_TARGET_ID = "__start";
/**
 * Pipeline class represents lage's understanding of the dependency graphs and wraps the promise graph implementations to execute tasks in order
 */
export declare class Pipeline {
    private workspace;
    private config;
    private cachedTransitiveTaskDependencies;
    /** Target represent a unit of work and the configuration of how to run it */
    targets: Map<string, PipelineTarget>;
    /** Target dependencies determine the run order of the targets  */
    dependencies: [string, string][];
    /** Internal cache of the package.json information */
    packageInfos: PackageInfos;
    /** Internal generated cache of the topological package graph */
    graph: TopologicalGraph;
    /** Internal cache of context */
    context: RunContext | undefined;
    constructor(workspace: Workspace, config: Config);
    /**
     * NPM Tasks are blindly placed in the task dependency graph, but we skip doing work if the package does not contain the specific npm task
     * @param task
     * @param info
     * @returns
     */
    private maybeRunNpmTask;
    /**
     * Generates a package target during the expansion of the shortcut syntax
     */
    private generatePackageTarget;
    /**
     * Expands the shorthand notation to pipeline targets (executable units)
     */
    private expandShorthandTargets;
    /**
     * Given an id & factory, generate targets configurations
     * @param id
     * @param factory
     */
    private generateFactoryTargets;
    /**
     * Converts target configuration to pipeline targets
     * @param id
     * @param target
     */
    private convertToPipelineTarget;
    /**
     * Adds a target definition (takes in shorthand, target config, or a target config factory)
     * @param id
     * @param targetDefinition
     */
    addTargetDefinition(id: string, targetDefinition: string[] | TargetConfig | TargetConfigFactory): void;
    /**
     * Adds all the target dependencies to the graph
     */
    addDependencies(): void;
    /**
     * Gets a list of package names that are direct or indirect dependencies of rootPackageName in this.graph,
     * and caches them on the Pipeline.
     * @param packageName the root package to begin walking from
     */
    getTransitiveGraphDependencies(packageName: string): Set<string>;
    generateTargetGraph(): [string, string][];
    loadConfig(config: Config): void;
    private getTargetPriority;
    /**
     * The "run" public API, accounts for setting distributed mode for the master lage node
     *
     * Runs the pipeline with the p-graph library
     *
     * Note: this is the abstraction layer on top of the external p-graph library to insulate
     *       any incoming changes to the library.
     */
    run(context: RunContext): Promise<void>;
}
