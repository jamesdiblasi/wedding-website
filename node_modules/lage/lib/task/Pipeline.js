"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pipeline = exports.START_TARGET_ID = void 0;
const generateTopologicalGraph_1 = require("../workspace/generateTopologicalGraph");
const NpmScriptTask_1 = require("./NpmScriptTask");
const p_graph_1 = __importDefault(require("p-graph"));
const path_1 = __importDefault(require("path"));
const getPipelinePackages_1 = require("./getPipelinePackages");
const taskId_1 = require("./taskId");
const WrappedTarget_1 = require("./WrappedTarget");
exports.START_TARGET_ID = "__start";
/**
 * Pipeline class represents lage's understanding of the dependency graphs and wraps the promise graph implementations to execute tasks in order
 */
class Pipeline {
    constructor(workspace, config) {
        this.workspace = workspace;
        this.config = config;
        this.cachedTransitiveTaskDependencies = new Map();
        /** Target represent a unit of work and the configuration of how to run it */
        this.targets = new Map([
            [
                exports.START_TARGET_ID,
                {
                    id: exports.START_TARGET_ID,
                    cwd: "",
                    run: () => { },
                    task: exports.START_TARGET_ID,
                    hidden: true,
                    cache: false,
                },
            ],
        ]);
        /** Target dependencies determine the run order of the targets  */
        this.dependencies = [];
        this.packageInfos = workspace.allPackages;
        this.graph = (0, generateTopologicalGraph_1.generateTopologicGraph)(workspace);
        this.loadConfig(config);
    }
    /**
     * NPM Tasks are blindly placed in the task dependency graph, but we skip doing work if the package does not contain the specific npm task
     * @param task
     * @param info
     * @returns
     */
    maybeRunNpmTask(task, info) {
        var _a;
        if (!((_a = info.scripts) === null || _a === void 0 ? void 0 : _a[task])) {
            return;
        }
        return (args) => {
            const npmTask = new NpmScriptTask_1.NpmScriptTask(task, info, this.config, args.logger);
            return npmTask.run();
        };
    }
    /**
     * Generates a package target during the expansion of the shortcut syntax
     */
    generatePackageTarget(packageName, task, deps) {
        const info = this.packageInfos[packageName];
        const id = (0, taskId_1.getTargetId)(packageName, task);
        return {
            id,
            task,
            cache: this.config.cache,
            outputGlob: this.config.cacheOptions.outputGlob,
            packageName: packageName,
            cwd: path_1.default.dirname(this.packageInfos[packageName].packageJsonPath),
            run: this.maybeRunNpmTask(task, info),
            // TODO: do we need to really merge this? Is this desired? (this is the OLD behavior)
            deps: this.targets.has(id) ? [...(this.targets.get(id).deps || []), ...deps] : deps,
        };
    }
    /**
     * Expands the shorthand notation to pipeline targets (executable units)
     */
    expandShorthandTargets(id, deps) {
        // shorthand gets converted to npm tasks
        const { packageName, task } = (0, taskId_1.getPackageAndTask)(id);
        const results = [];
        let packages = [];
        if (packageName) {
            // specific case in definition (e.g. 'package-name#test': ['build'])
            packages.push(packageName);
        }
        else {
            // generic case in definition (e.g. 'test': ['build'])
            packages = Object.entries(this.packageInfos).map(([pkg, _info]) => pkg);
        }
        for (const packageWithScript of packages) {
            results.push(this.generatePackageTarget(packageWithScript, task, deps));
        }
        return results;
    }
    /**
     * Given an id & factory, generate targets configurations
     * @param id
     * @param factory
     */
    generateFactoryTargets(factory) {
        const targets = factory({
            config: this.config,
            cwd: this.workspace.root,
        });
        return Array.isArray(targets) ? targets : [targets];
    }
    /**
     * Converts target configuration to pipeline targets
     * @param id
     * @param target
     */
    convertToPipelineTarget(id, index, target) {
        if (target.type === "global") {
            const targetId = `${id}.${index}`;
            return [
                Object.assign(Object.assign({}, target), { id: targetId, cache: target.cache !== false, cwd: this.workspace.root, task: id, run: () => { } }),
            ];
        }
        else if (id.includes("#")) {
            const { packageName: pkg, task } = (0, taskId_1.getPackageAndTask)(id);
            return [
                Object.assign(Object.assign({}, target), { id, cache: target.cache !== false, task: id, cwd: path_1.default.dirname(this.packageInfos[pkg].packageJsonPath), packageName: pkg, run: this.maybeRunNpmTask(task, this.packageInfos[pkg]) }),
            ];
        }
        else {
            const packages = Object.entries(this.packageInfos);
            return packages.map(([pkg, _info]) => {
                const targetId = (0, taskId_1.getTargetId)(pkg, id);
                return Object.assign(Object.assign({}, target), { id: targetId, cache: target.cache !== false, task: id, cwd: path_1.default.dirname(this.packageInfos[pkg].packageJsonPath), packageName: pkg, run: this.maybeRunNpmTask(id, this.packageInfos[pkg]) });
            });
        }
    }
    /**
     * Adds a target definition (takes in shorthand, target config, or a target config factory)
     * @param id
     * @param targetDefinition
     */
    addTargetDefinition(id, targetDefinition) {
        // e.g. build: ["^build", "prepare"]
        if (Array.isArray(targetDefinition)) {
            const targets = this.expandShorthandTargets(id, targetDefinition);
            for (const target of targets) {
                this.targets.set(target.id, target);
            }
        }
        else {
            // e.g. build: { /* target config */ }
            const targets = typeof targetDefinition === "function" ? this.generateFactoryTargets(targetDefinition) : [targetDefinition];
            targets.forEach((target, index) => {
                const pipelineTargets = this.convertToPipelineTarget(id, index, target);
                for (const pipelineTarget of pipelineTargets) {
                    this.targets.set(pipelineTarget.id, pipelineTarget);
                }
            });
        }
    }
    /**
     * Adds all the target dependencies to the graph
     */
    addDependencies() {
        const targets = [...this.targets.values()];
        for (const target of targets) {
            const { deps, packageName, id } = target;
            // Always start with a root node with a special "START_TARGET_ID"
            this.dependencies.push([exports.START_TARGET_ID, id]);
            // Skip any targets that have no "deps" specified
            if (!deps || deps.length === 0) {
                continue;
            }
            /**
             * Now for every deps defined, we need to "interpret" it based on the syntax:
             * - for any deps like package#task, we simply add the singular dependency (source could be a single package or all packages)
             * - for anything that starts with a "^", we add the package-tasks according to the topological package graph
             *    NOTE: in a non-strict mode (TODO), the dependencies can come from transitive task dependencies
             * - for anything that starts with a "^^", we add the package-tasks from the transitive dependencies in the topological
             *    package graph.
             * - for {"pkgA#task": ["dep"]}, we interpret to add "pkgA#dep"
             * - for anything that is a string without a "^", we treat that string as the name of a task, adding all targets that way
             *    NOTE: in a non-strict mode (TODO), the dependencies can come from transitive task dependencies
             *
             * We interpret anything outside of these conditions as invalid
             */
            for (const dep of deps) {
                if (dep.includes("#")) {
                    // package and task as deps
                    this.dependencies.push([dep, id]);
                }
                else if (dep.startsWith("^") && packageName) {
                    // topo dep -> build: ['^build']
                    const [depTask, dependencySet] = dep.startsWith("^^")
                        ? [dep.substr(2), [...this.getTransitiveGraphDependencies(packageName)]]
                        : [dep.substr(1), this.graph[packageName].dependencies];
                    const dependencyIds = targets
                        .filter((needle) => {
                        const { task, packageName: needlePackageName } = needle;
                        return task === depTask && dependencySet.some((depPkg) => depPkg === needlePackageName);
                    })
                        .map((needle) => needle.id);
                    for (const dependencyId of dependencyIds) {
                        this.dependencies.push([dependencyId, id]);
                    }
                }
                else if (packageName) {
                    // Intra package task dependency - only add the target dependency if it exists in the pipeline targets lists
                    if (this.targets.has((0, taskId_1.getTargetId)(packageName, dep))) {
                        this.dependencies.push([(0, taskId_1.getTargetId)(packageName, dep), target.id]);
                    }
                }
                else if (!dep.startsWith("^")) {
                    const dependencyIds = targets.filter((needle) => needle.task === dep).map((needle) => needle.id);
                    for (const dependencyId of dependencyIds) {
                        this.dependencies.push([dependencyId, id]);
                    }
                }
                else {
                    throw new Error(`invalid pipeline config detected: ${target.id}`);
                }
            }
        }
    }
    /**
     * Gets a list of package names that are direct or indirect dependencies of rootPackageName in this.graph,
     * and caches them on the Pipeline.
     * @param packageName the root package to begin walking from
     */
    getTransitiveGraphDependencies(packageName) {
        var _a, _b;
        const cachedResult = this.cachedTransitiveTaskDependencies.get(packageName);
        if (cachedResult) {
            return cachedResult === "walk-in-progress"
                ? // There is a recursive walk over this set of dependencies in progress.
                    // If we hit this case, that means that a dependency of this package depends on it.
                    //
                    // In this case we return an empty set to omit this package and it's downstream from its
                    // dependency
                    new Set()
                : // we already computed this for this package, return the cached result.
                    cachedResult;
        }
        else {
            // No cached result. Compute now with a recursive walk
            // mark that we are traversing this package to prevent infinite recursion
            // in cases of circular dependencies
            this.cachedTransitiveTaskDependencies.set(packageName, "walk-in-progress");
            let immediateDependencies = (_b = (_a = this.graph[packageName]) === null || _a === void 0 ? void 0 : _a.dependencies) !== null && _b !== void 0 ? _b : [];
            // build the set of transitive dependencies by recursively walking the
            // immediate dependencies' dependencies.
            let transitiveDepSet = new Set(immediateDependencies);
            for (let immediateDependency of immediateDependencies) {
                for (let transitiveSubDependency of this.getTransitiveGraphDependencies(immediateDependency)) {
                    transitiveDepSet.add(transitiveSubDependency);
                }
            }
            // Cache the result and return
            this.cachedTransitiveTaskDependencies.set(packageName, transitiveDepSet);
            return transitiveDepSet;
        }
    }
    generateTargetGraph() {
        const scope = (0, getPipelinePackages_1.getPipelinePackages)(this.workspace, this.config);
        const tasks = this.config.command;
        const targetGraph = [];
        const queue = [];
        for (const task of tasks) {
            // package task
            for (const pkg of scope) {
                if (this.targets.has((0, taskId_1.getTargetId)(pkg, task))) {
                    queue.push((0, taskId_1.getTargetId)(pkg, task));
                    targetGraph.push([exports.START_TARGET_ID, (0, taskId_1.getTargetId)(pkg, task)]);
                }
            }
            // if we have globals, send those into the queue
            for (const target of this.targets.values()) {
                if (target.task === task && !target.packageName) {
                    queue.push(target.id);
                    targetGraph.push([exports.START_TARGET_ID, target.id]);
                }
            }
        }
        const visited = new Set();
        while (queue.length > 0) {
            const id = queue.shift();
            if (visited.has(id)) {
                continue;
            }
            visited.add(id);
            const { packageName, task } = (0, taskId_1.getPackageAndTask)(id);
            if (!packageName) {
                // global - find all deps in the form of "task.index"
                for (const [from, to] of this.dependencies) {
                    if (to.includes(".")) {
                        const toTaskName = to.split(".")[0];
                        if (toTaskName === task) {
                            targetGraph.push([from, to]);
                            if (from) {
                                queue.push(from);
                            }
                        }
                    }
                }
            }
            else {
                // package dep
                for (const [from, to] of this.dependencies) {
                    if (to === id) {
                        targetGraph.push([from, to]);
                        if (from) {
                            queue.push(from);
                        }
                    }
                }
            }
        }
        return targetGraph;
    }
    loadConfig(config) {
        this.config = config;
        for (const [id, targetDefinition] of Object.entries(this.config.pipeline)) {
            this.addTargetDefinition(id, targetDefinition);
        }
        // add target definitions for unknown tasks
        const knownTasks = new Set();
        for (const target of this.targets.values()) {
            knownTasks.add(target.task);
        }
        knownTasks.add(exports.START_TARGET_ID);
        const unknownCommands = this.config.command.filter((cmd) => !knownTasks.has(cmd));
        for (const command of unknownCommands) {
            this.addTargetDefinition(command, [`^${command}`]);
        }
        this.addDependencies();
    }
    getTargetPriority(target) {
        var _a, _b;
        return target.priority !== undefined
            ? target.priority
            : (_b = (_a = this.config.priorities) === null || _a === void 0 ? void 0 : _a.find((priority) => priority.package === target.packageName && priority.task === target.task)) === null || _b === void 0 ? void 0 : _b.priority;
    }
    /**
     * The "run" public API, accounts for setting distributed mode for the master lage node
     *
     * Runs the pipeline with the p-graph library
     *
     * Note: this is the abstraction layer on top of the external p-graph library to insulate
     *       any incoming changes to the library.
     */
    async run(context) {
        this.context = context;
        const nodeMap = new Map();
        const targetGraph = this.generateTargetGraph();
        for (const [from, to] of targetGraph) {
            const fromTarget = this.targets.get(from);
            const toTarget = this.targets.get(to);
            for (const target of [fromTarget, toTarget]) {
                nodeMap.set(target.id, {
                    run: () => {
                        if (target.id === exports.START_TARGET_ID || !target.run) {
                            return Promise.resolve();
                        }
                        const wrappedTask = new WrappedTarget_1.WrappedTarget(target, this.workspace.root, this.config, context);
                        return wrappedTask.run();
                    },
                    priority: this.getTargetPriority(target),
                });
            }
        }
        await (0, p_graph_1.default)(nodeMap, targetGraph).run({
            concurrency: this.config.concurrency,
            continue: this.config.continue,
        });
    }
}
exports.Pipeline = Pipeline;
//# sourceMappingURL=Pipeline.js.map