"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteFallbackCacheProvider = void 0;
const backfill_cache_1 = require("backfill-cache");
const logger_1 = require("../logger");
/**
 * Remote Fallback Cache Provider
 *
 * This backfill cache provider will fallback to a remote cache provider if the local cache does not contain the item.
 * It will also automatically populate the local cache with the remote cache.
 */
class RemoteFallbackCacheProvider {
    constructor(cacheOptions, logger, cwd) {
        this.cacheOptions = cacheOptions;
        this.localCacheStorageProvider = (0, backfill_cache_1.getCacheStorageProvider)({
            provider: "local",
        }, cacheOptions.internalCacheFolder, logger, cwd, cacheOptions.incrementalCaching);
        // Remote providers should have a provider name of something other than "local" OR it is
        // a custom provider (currently S3 would be a custom provider)
        const isRemoteProvider = (0, backfill_cache_1.isCustomProvider)(cacheOptions.cacheStorageConfig) ||
            (typeof cacheOptions.cacheStorageConfig.provider === "string" && !cacheOptions.cacheStorageConfig.provider.includes("local"));
        if (isRemoteProvider) {
            logger.silly("remote provider enabled");
            this.remoteCacheStorageProvider = (0, backfill_cache_1.getCacheStorageProvider)(cacheOptions.cacheStorageConfig, cacheOptions.internalCacheFolder, logger, cwd, cacheOptions.incrementalCaching);
        }
    }
    async fetch(hash) {
        if (!this.cacheOptions.skipLocalCache) {
            RemoteFallbackCacheProvider.localHits[hash] = await this.localCacheStorageProvider.fetch(hash);
            logger_1.logger.silly(`local cache fetch: ${hash} ${RemoteFallbackCacheProvider.localHits[hash]}`);
        }
        if (!RemoteFallbackCacheProvider.localHits[hash] && this.remoteCacheStorageProvider) {
            RemoteFallbackCacheProvider.remoteHits[hash] = await this.remoteCacheStorageProvider.fetch(hash);
            logger_1.logger.silly(`remote fallback fetch: ${hash} ${RemoteFallbackCacheProvider.remoteHits[hash]}`);
            return RemoteFallbackCacheProvider.remoteHits[hash];
        }
        return RemoteFallbackCacheProvider.localHits[hash];
    }
    async put(hash, filesToCache) {
        const putPromises = [];
        // Write local cache if it doesn't already exist, or if the the hash isn't in the localHits
        const shouldWriteLocalCache = !this.isLocalHit(hash) && !this.cacheOptions.skipLocalCache;
        if (shouldWriteLocalCache) {
            logger_1.logger.silly(`local cache put: ${hash}`);
            putPromises.push(this.localCacheStorageProvider.put(hash, filesToCache));
        }
        // Write to remote if there is a no hit in the remote cache, and remote cache storage provider, and that the "writeRemoteCache" config flag is set to true
        const shouldWriteRemoteCache = !this.isRemoteHit(hash) && !!this.remoteCacheStorageProvider && this.cacheOptions.writeRemoteCache;
        if (shouldWriteRemoteCache) {
            logger_1.logger.silly(`remote fallback put: ${hash}`);
            const remotePut = this.remoteCacheStorageProvider.put(hash, filesToCache);
            putPromises.push(remotePut);
        }
        await Promise.all(putPromises);
    }
    isRemoteHit(hash) {
        return hash in RemoteFallbackCacheProvider.remoteHits && RemoteFallbackCacheProvider.remoteHits[hash];
    }
    isLocalHit(hash) {
        return hash in RemoteFallbackCacheProvider.localHits && RemoteFallbackCacheProvider.localHits[hash];
    }
}
exports.RemoteFallbackCacheProvider = RemoteFallbackCacheProvider;
RemoteFallbackCacheProvider.localHits = {};
RemoteFallbackCacheProvider.remoteHits = {};
//# sourceMappingURL=RemoteFallbackCacheProvider.js.map